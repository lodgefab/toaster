/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { Edges, Html, useGLTF } from "@react-three/drei";
import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";
import { useFrame } from "@react-three/fiber";
import { motion } from "framer-motion-3d";
import { useCursor } from "../../src/utils/useCursor";
import {spring} from '../../src/styles'
import { useAnimation } from "framer-motion";

type GLTFResult = GLTF & {
  nodes: {
    Cube001: THREE.Mesh;
    Cube001_1: THREE.Mesh;
    handle: THREE.Mesh;
    Cube004: THREE.Mesh;
    Cube004_1: THREE.Mesh;
  };
  materials: {
    toaster_black: THREE.MeshStandardMaterial;
    bread_plain: THREE.MeshStandardMaterial;
    bread_ear: THREE.MeshStandardMaterial;
  };
};

export default function Model(props: JSX.IntrinsicElements["group"], isReady: boolean) {
  const group = useRef<THREE.Group>();
  const { nodes, materials } = useGLTF(
    "/models/hero003.glb"
  ) as unknown as GLTFResult;
  const [isUp, setUp] = useState(false);
  
  const toastVariants = {
    variantUp: {
      y: [-0.2,1.0,0.6],
    },
    variantDown: {
      y: -0.2,
      // rotateY:3.2,
    },
  };
  const handleVariants = {
    variantUp: { y: 0.2 },
    variantDown: { y: -0.2 },
  };


  
  
  
  // 読み込み後アニメーション
  const initAnimation = useAnimation();

  async function sequence() {
    await initAnimation.start({ rotateY: 0 });
    initAnimation.start({ rotateY: 6.5});
  }
  useEffect(()=>{
    const load = setTimeout(() => {
      sequence()
    }, 0.1 * 1000);
  },[])

  // Toast Popup アニメーション
  useEffect(() => {

    const timer = setTimeout(() => {
      isReady && setUp(!isUp)
    }, 4 * 1000);
    return () => {
      clearTimeout(timer);
    };
  }, [isUp]);
  
  // 浮遊アニメーション
  useFrame((state) => {
    const t = state.clock.getElapsedTime();
    group.current!.position.y = (-4 + Math.sin(t * 2)) / 10;
  });

  return (
    <group ref={group} {...props} dispose={null} >
      <motion.group 
        animate={{rotateY:6.5}}
        transition={{ ...spring, mass:10, damping: 500}}
      >
        {/* Body */}
        <group position={[0, 0.21, 0]}>
          <mesh castShadow receiveShadow geometry={nodes.Cube001.geometry}>
            <meshStandardMaterial transparent />
            <Edges />
          </mesh>
          <mesh castShadow receiveShadow geometry={nodes.Cube001_1.geometry}>
            <meshStandardMaterial transparent />
            <Edges />
          </mesh>
        </group>
        
        {/* Handle */}
        <motion.group
          whileHover={{ y: -0.08 }}
        >
          <motion.mesh
            castShadow
            receiveShadow
            geometry={nodes.handle.geometry}
            position={[0.55, -0.09, 0]}
            onClick={() => {
              setUp(!isUp);
            }}
            
            variants={handleVariants}
            animate={isUp ? "variantUp" : "variantDown"}
            {...useCursor()}
            transition={{ ...spring, damping: 100}}
          >
            <meshStandardMaterial transparent />
            <Edges />
          </motion.mesh>
        </motion.group>
        
        {/* Toast */}
        <motion.group
          position={[0, -0.09, 0.17]}
          variants={toastVariants}
          animate={isUp ? "variantUp" : "variantDown"}
          transition={{ ...spring, damping: 100,duration:.5, time:[0.5,1]}}
        >
          <motion.mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube004.geometry}
          >
            <Html
              style={{
                transition: "all 0.2s",
                opacity: 1,
                transform: `scale(1)`,
              }}
              distanceFactor={4}
              position={[0, 2, 0.1]}
              transform
              occlude
            >
              <span>Recipe</span>
            </Html>
            <meshStandardMaterial transparent />
            <Edges />
          </motion.mesh>
          
          <motion.mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube004_1.geometry}
          >
            <meshStandardMaterial transparent />
            <Edges />
          </motion.mesh>
        </motion.group>
      </motion.group>
      {/* <gridHelper args={[10, 40, '#aaaaaa', '#cccccc']} position={[-0.25, 0, 0]} rotation={[0, 0, Math.PI / 2]} /> */}
    </group>
  );
}

useGLTF.preload("/models/hero003.glb");
