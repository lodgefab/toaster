/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useRef, useState } from "react";
import { Edges, Html, useGLTF } from "@react-three/drei";
import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";
import { useFrame } from "@react-three/fiber";
import { motion } from "framer-motion-3d";
import { useCursor } from "../../src/utils/useCursor";
import {spring} from '../../src/styles'

type GLTFResult = GLTF & {
  nodes: {
    Cube001: THREE.Mesh;
    Cube001_1: THREE.Mesh;
    handle: THREE.Mesh;
    Cube004: THREE.Mesh;
    Cube004_1: THREE.Mesh;
  };
  materials: {
    toaster_black: THREE.MeshStandardMaterial;
    bread_plain: THREE.MeshStandardMaterial;
    bread_ear: THREE.MeshStandardMaterial;
  };
};

export default function Model(props: JSX.IntrinsicElements["group"]) {
  const group = useRef<THREE.Group>();
  const { nodes, materials } = useGLTF(
    "/models/hero003.glb"
  ) as unknown as GLTFResult;
  const [isUp, setUp] = useState(false);
  
  const toastVariants = {
    variantUp: {
      y: 0.4,
      transition: {
        damping: 100,
      },
    },
    variantDown: { y: -0.2 },
  };
  const handleVariants = {
    variantUp: { y: 0.2 },
    variantDown: { y: -0.2 },
  };

  useFrame((state) => {
    const t = state.clock.getElapsedTime();
    //Hole Animation
    group.current?.rotation.set(
      0,
      Math.sin(t / 4) / 4,
      0.3 - (1 + Math.sin(t / 4)) / 8
    );
    group.current!.position.y = (1 + Math.sin(t * 2)) / 10;
    //Toast Animation
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group position={[0, 0.21, 0]}>
        <mesh castShadow receiveShadow geometry={nodes.Cube001.geometry}>
          <meshStandardMaterial transparent />
          <Edges />
        </mesh>
        <mesh castShadow receiveShadow geometry={nodes.Cube001_1.geometry}>
          <meshStandardMaterial transparent />
          <Edges />
        </mesh>
      </group>
      <motion.mesh
        castShadow
        receiveShadow
        geometry={nodes.handle.geometry}
        position={[0.55, -0.09, 0]}
        onClick={() => {
          setUp(!isUp);
        }}
        variants={handleVariants}
        animate={isUp ? "variantUp" : "variantDown"}
        {...useCursor()}
        transition={{ ...spring, damping: 100}}
      >
        <meshStandardMaterial transparent />
        <Edges />
      </motion.mesh>
      {/* Toast */}
      <motion.group
        position={[0, -0.09, 0.17]}
        variants={toastVariants}
        animate={isUp ? "variantUp" : "variantDown"}
        transition={{ ...spring, damping: 100}}
      >
        <motion.mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube004.geometry}
          material={materials.bread_plain}
        >
          <Html
            style={{
              transition: "all 0.2s",
              opacity: 1,
              transform: `scale(1)`,
            }}
            distanceFactor={4}
            position={[0, 2, 0.1]}
            transform
            occlude
          >
            <span>Size</span>
          </Html>
        </motion.mesh>
        <motion.mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube004_1.geometry}
        >
          <meshStandardMaterial transparent />
          <Edges />
        </motion.mesh>
      </motion.group>
    </group>
  );
}

useGLTF.preload("/models/hero003.glb");
