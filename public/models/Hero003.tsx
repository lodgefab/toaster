/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useContext, useEffect, useMemo, useRef, useState } from "react";
import {
  Edges,
  Html,
  useGLTF,
  useTexture,
  Image,
  Text,
  Sphere,
  Circle,
} from "@react-three/drei";
import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";
import { useFrame } from "@react-three/fiber";
import { motion as motion3d } from "framer-motion-3d";
import { motion } from "framer-motion";
import { useCursor } from "../../src/utils/useCursor";
import { color, spring, zIndex } from "../../src/styles";
import { useAnimation, useCycle } from "framer-motion";
import styled from "@emotion/styled";
import { makeConsoleLogger } from "@notionhq/client/build/src/logging";
import {
  useAddress,
  useClaimNFT,
  useContract,
  useNetworkMismatch,
} from "@thirdweb-dev/react";
import { useConnectWallet } from "../../src/hooks/useConnectWallet";
import { proxy, useSnapshot } from "valtio";
import { sceneState } from "../../src/utils/sceneState";
import { AppContext } from "../../src/contexts/AppContextProvider";
import { NftContractContext } from "../../src/contexts/NFTContractProvider";
import { Depth, Fresnel, LayerMaterial } from "lamina";
import { MeshBasicMaterial } from "three";
import { LayerMaterialProps, LayerMaterialParameters, LayerProps } from "lamina/types";
import { useControls } from 'leva';

type GLTFResult = GLTF & {
  nodes: {
    Cube001: THREE.Mesh;
    Cube001_1: THREE.Mesh;
    handle: THREE.Mesh;
    Cube004: THREE.Mesh;
    Cube004_1: THREE.Mesh;
  };
  materials: {
    toaster_black: THREE.MeshStandardMaterial;
    bread_plain: THREE.MeshStandardMaterial;
    bread_ear: THREE.MeshStandardMaterial;
  };
};

export default function Model(
  props: JSX.IntrinsicElements["group"],
  isReady: boolean
) {
  const group = useRef<THREE.Group>();
  const { nodes, materials } = useGLTF(
    "/models/hero003.glb"
  ) as unknown as GLTFResult;
  const [isUp, setUp] = useState(false);
  const {isSuccessDialogOpened} = useContext(AppContext)

  const depthRef0 = useRef<any>(null!)
  const depthRef1 = useRef<any>(null!)
  const depthRef2 = useRef<any>(null!)
  const depthRef3 = useRef<any>(null!)

  
  const  gradient  = 0.75
  

  const {isConnected, isClaiming} = useSnapshot(sceneState)
  //address„ÅØsceneState:string„Åß„ÅØ‰ª£Áî®„Åß„Åç„Å™„ÅÑÂèØËÉΩÊÄß
  const { address, connectWallet } = useConnectWallet();

  //networkDetection
  const networkMismatch = useNetworkMismatch();

  //TODO „ÅÇ„Å®„Åßcontext„Å´„Åæ„Å®„ÇÅ„Çã
  // Connect to the Edition Drop contract
  // SDK v2->v3
  const editionDropContract  = useContract(process.env.NEXT_PUBLIC_CONTRACT_ADDRESS, 'edition-drop');

  

  // Claim an NFT (and update the nfts above)
  const { mutate: claimNft, isLoading, error } =
    useClaimNFT(editionDropContract.contract);
  if (error) {
      console.error("failed to claim nft", error);
  }

  
  const toastVariants = {
    variantUp: {
      y: [-0.2, 1.0, 0.6],
    },
    variantDown: {
      y: -0.2,
      // rotateY:3.2,
    },
  };
  const handleVariants = {
    variantUp: { y: 0.2 },
    variantDown: { y: -0.2 },
  };

  //Toast„Å´Ë°®Á§∫„Åô„Çãimage„ÅÆpath
  const [path, cyclePath] = useCycle(
    "/images/recipe001.png",
    "/images/recipe002.png"
  );
  //Push to mint„ÅÆË°®Á§∫
  const pushTexture = useTexture("/images/push_to_mint.png");

  // Toast Popup „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
  useEffect(() => {
    const timer = setTimeout(() => {
      !isUp && cyclePath();
      setTimeout(() => {
        isReady && setUp(!isUp);
      }, 1 * 1000);
    }, 3 * 1000);
    return () => {
      clearTimeout(timer);
    };
  }, [isUp]);

  
  // ÊµÆÈÅä„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
  useFrame((state) => {
    const t = state.clock.getElapsedTime();
    group.current!.position.y = (-4 + Math.sin(t * 2)) / 10;
    //„É¨„Éê„Éº„ÅÆGradient„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
    const sin = Math.sin(state.clock.elapsedTime / 2)
    const cos = Math.cos(state.clock.elapsedTime / 2)

    
    depthRef0.current!.origin.set(cos / 2, 0, 0)
    depthRef1.current!.origin.set(cos, sin, cos)
    depthRef2.current!.origin.set(sin, cos, sin)
    depthRef3.current!.origin.set(cos, sin, cos)
  });

  return (
    <>
    {/* @ts-ignore */}
      <group ref={group} {...props} dispose={null}>
        <motion3d.group
          animate={{ rotateY: 6.3 }}
          transition={{ ...spring, mass: 10, damping: 500 }}
        >
          {/* Body */}
          <group position={[0, 0.21, 0]}>
            <mesh castShadow receiveShadow geometry={nodes.Cube001.geometry}>
              <meshStandardMaterial transparent />
              <Edges />
            </mesh>
            <mesh castShadow receiveShadow geometry={nodes.Cube001_1.geometry}>
              <meshStandardMaterial transparent />
              <Edges />
            </mesh>
          </group>

          {/* Handle */}
          <motion3d.group whileHover={{ y: -0.08 }}>
            <motion3d.mesh
              castShadow
              receiveShadow
              geometry={nodes.handle.geometry}
              position={[0.55, -0.09, 0]}
              onClick={() => {
                setUp(!isUp);
              }}
              variants={handleVariants}
              animate={isUp ? "variantUp" : "variantDown"}
              {...useCursor()}
              transition={{ ...spring, damping: 100 }}
            >
              {isConnected ? (
                <>
                  {/* <meshStandardMaterial transparent color={"orange"} /> */}
                  <LayerMaterial toneMapped={false}>
                    <Depth  ref={depthRef0} colorA="#ff0080" colorB="black" alpha={1} mode="normal" near={0.5 * gradient} far={0.5} origin={[0,0,0]} />
                    <Depth ref={depthRef1} colorA="blue" colorB="#f7b955" alpha={1} mode="add" near={2 * gradient} far={2} origin={[0,1,1]} />
                    <Depth ref={depthRef2} colorA="green" colorB="#f7b955" alpha={1} mode="add" near={3 * gradient} far={3} origin={[0,1,-1]} />
                    <Depth ref={depthRef3} colorA="white" colorB="red" alpha={1} mode="overlay" near={1.5 * gradient} far={1.5} origin={[0,-1,-1]} />
                    <Fresnel mode="add" color="white" intensity={0.5} power={1.5} bias={0.05} />
                  </LayerMaterial>
                  <Edges color="white" />
                  <Html
                    style={{
                      transition: "all 0.2s",
                      opacity: 1,
                      // transform: `scale(1)`,
                      width: 120,
                      height: 120,
                      padding: 0,
                    }}
                    zIndexRange={[zIndex.elevation.ev5, 0]}
                    position={[0.8, 0.9, 0]}
                    center
                  >
                    <MintText>
                      {networkMismatch
                        ? `Wrong Network`
                        : isClaiming
                        ? `Minting`
                        : `Press To\nMint Toastüçû`}
                    </MintText>
                    <MintCursor
                      whileHover={{ scale: 1.1 }}
                      onClick={() => {
                        isConnected &&
                          address &&
                          claimNft(
                            {
                              quantity: 1,
                              tokenId: 0,
                              to: address,
                            },
                            {
                              onSuccess: (data) => {
                                sceneState.isSuccessModalOpen = true;
                                // @ts-ignore
                                sceneState.txHash = data.receipt.transactionHash;
                              },
                              onError: (error) => {
                                const e = error as Error;
                                alert((e?.message as string) || "Something went wrong");
                              },
                            }
                          );
                      }}
                    />
                  </Html>
                </>
              ) : (
                <meshStandardMaterial transparent />
              )}

              <Edges />
            </motion3d.mesh>
          </motion3d.group>

          {/* Toast */}
          <motion3d.group
            position={[0, -0.09, 0.17]}
            variants={toastVariants}
            animate={isUp ? "variantUp" : "variantDown"}
            transition={{
              ...spring,
              damping: 100,
              duration: 0.5,
              time: [0.5, 1],
            }}
          >
            <mesh castShadow receiveShadow geometry={nodes.Cube004.geometry}>
              <Html
                style={{
                  transition: "all 0.2s",
                  opacity: 1,
                  transform: `scale(1)`,
                  width: 110,
                  height: 116,
                  padding: 0,
                }}
                distanceFactor={4}
                position={[0, 1.3, 0.1]}
                zIndexRange={[zIndex.elevation.ev5, 0]}
                transform
                occlude
              >
                <ToasterWrap>
                  <ToasterRecipe src={path} alt={"image"} />
                </ToasterWrap>
              </Html>
              <meshStandardMaterial transparent />
              <Edges />
            </mesh>

            <mesh castShadow receiveShadow geometry={nodes.Cube004_1.geometry}>
              <meshStandardMaterial transparent />
              <Edges />
            </mesh>
          </motion3d.group>
        </motion3d.group>
      </group>
    </>
  );
}

useGLTF.preload("/models/hero003.glb");

const ToasterWrap = styled.div`
  display: flex;
  flex-direction: row;
`;
const ToasterRecipe = styled.img`
  object-fit: contain;
  width: 100%;
  height: 100%;
`;
const ToasterText = styled.ul`
  width: 20%;
  li {
    width: 100%;
    height: 2px;
    background-color: #999;
    margin: 0 0 4px;
  }
`;

const ToasterImage = styled.div`
  border: 0.5px solid ${color.content.dark};
  width: 100%;
  height: 24px;
`;
const MintCursor = styled(motion.div)`
  border-radius: 999px;
  border: 1px solid ${color.content.dark};
  position: absolute;
  width: 100%;
  height: 100%;
  cursor: pointer;
  /* &:before{
    content:'';
    position:absolute;
    display:block;
    width:100%;
    height:100%;
    background-image: url('/icons/elipse.svg');
    background-size: contain;
  } */
`;

const MintText = styled.p`
  text-align: left;
  position: absolute;
  top: 50%;
  left: -110%;
  transform: translate(0, -50%);
  width: 100%;
`;
